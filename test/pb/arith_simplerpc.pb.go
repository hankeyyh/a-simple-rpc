// Code generated by protoc-gen-simple-rpc. DO NOT EDIT.

package pb

import (
	context "context"
	client "github.com/hankeyyh/a-simple-rpc/client"
	protocol "github.com/hankeyyh/a-simple-rpc/protocol"
	server "github.com/hankeyyh/a-simple-rpc/server"
	proto "google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = context.TODO
var _ = server.NewServer
var _ = client.NewClient
var _ = protocol.NewMessage
var _ = proto.Marshal

// ================== interface skeleton ===================
type Arith interface {
	Add(ctx context.Context, args *Args, reply *Reply) (err error)
	Sub(ctx context.Context, args *Args, reply *Reply) (err error)
	Mul(ctx context.Context, args *Args, reply *Reply) (err error)
	Divide(ctx context.Context, args *Args, reply *Reply) (err error)
}

// ================== service register ===================
func RegisterArithServiceByProto(svr *server.Server, instance interface{}) error {
	sd := genArithServiceDescriptor()
	return svr.RegisterByProto("Arith", instance, sd)
}

// ================== client stub ===================
// Arith is a client wrapped XClient.
type ArithClient struct {
	xclient client.XClient
}

// newArithClient wraps a XClient as ArithClient.
// You can pass a shared XClient object created by NewXClientForArith.
func NewArithClient(xclient client.XClient) *ArithClient {
	return &ArithClient{xclient: xclient}
}

// NewXClientForArith creates a XClient.
// You can configure this client with more options such as etcd registry, serialize type, select algorithm and fail mode.
func NewXClientForArith(failMode client.FailMode, selectMode client.SelectMode, d client.ServiceDiscovery, opt client.Option) client.XClient {
	opt.SerializeType = protocol.ProtoBuffer

	xclient := client.NewXClient("Arith", failMode, selectMode, d, opt)

	return xclient
}

func (c *ArithClient) Add(ctx context.Context, args *Args) (reply *Reply, err error) {
	reply = &Reply{}
	err = c.xclient.Call(ctx, "Add", args, reply)
	return reply, err
}
func (c *ArithClient) Sub(ctx context.Context, args *Args) (reply *Reply, err error) {
	reply = &Reply{}
	err = c.xclient.Call(ctx, "Sub", args, reply)
	return reply, err
}
func (c *ArithClient) Mul(ctx context.Context, args *Args) (reply *Reply, err error) {
	reply = &Reply{}
	err = c.xclient.Call(ctx, "Mul", args, reply)
	return reply, err
}
func (c *ArithClient) Divide(ctx context.Context, args *Args) (reply *Reply, err error) {
	reply = &Reply{}
	err = c.xclient.Call(ctx, "Divide", args, reply)
	return reply, err
}
func (c *ArithClient) Close() error {
	return c.xclient.Close()
}

// ================== service descriptor ===================
func genArithServiceDescriptor() *descriptorpb.ServiceDescriptorProto {
	serviceDescriptorRaw := []byte{
		0x0a, 0x05, 0x41, 0x72, 0x69, 0x74, 0x68, 0x12, 0x32, 0x0a, 0x03, 0x41, 0x64, 0x64, 0x12, 0x0b,
		0x2e, 0x61, 0x72, 0x69, 0x74, 0x68, 0x2e, 0x41, 0x72, 0x67, 0x73, 0x1a, 0x0c, 0x2e, 0x61, 0x72,
		0x69, 0x74, 0x68, 0x2e, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x22, 0x10, 0x9a, 0xf1, 0x04, 0x0c, 0x0a,
		0x04, 0x2f, 0x61, 0x64, 0x64, 0x12, 0x04, 0x2f, 0x61, 0x64, 0x64, 0x12, 0x32, 0x0a, 0x03, 0x53,
		0x75, 0x62, 0x12, 0x0b, 0x2e, 0x61, 0x72, 0x69, 0x74, 0x68, 0x2e, 0x41, 0x72, 0x67, 0x73, 0x1a,
		0x0c, 0x2e, 0x61, 0x72, 0x69, 0x74, 0x68, 0x2e, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x22, 0x10, 0x9a,
		0xf1, 0x04, 0x0c, 0x0a, 0x04, 0x2f, 0x73, 0x75, 0x62, 0x12, 0x04, 0x2f, 0x73, 0x75, 0x62, 0x12,
		0x32, 0x0a, 0x03, 0x4d, 0x75, 0x6c, 0x12, 0x0b, 0x2e, 0x61, 0x72, 0x69, 0x74, 0x68, 0x2e, 0x41,
		0x72, 0x67, 0x73, 0x1a, 0x0c, 0x2e, 0x61, 0x72, 0x69, 0x74, 0x68, 0x2e, 0x52, 0x65, 0x70, 0x6c,
		0x79, 0x22, 0x10, 0x9a, 0xf1, 0x04, 0x0c, 0x0a, 0x04, 0x2f, 0x6d, 0x75, 0x6c, 0x12, 0x04, 0x2f,
		0x6d, 0x75, 0x6c, 0x12, 0x35, 0x0a, 0x06, 0x44, 0x69, 0x76, 0x69, 0x64, 0x65, 0x12, 0x0b, 0x2e,
		0x61, 0x72, 0x69, 0x74, 0x68, 0x2e, 0x41, 0x72, 0x67, 0x73, 0x1a, 0x0c, 0x2e, 0x61, 0x72, 0x69,
		0x74, 0x68, 0x2e, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x22, 0x10, 0x9a, 0xf1, 0x04, 0x0c, 0x0a, 0x04,
		0x2f, 0x64, 0x69, 0x76, 0x12, 0x04, 0x2f, 0x64, 0x69, 0x76, 0x1a, 0x0a, 0x92, 0xf1, 0x04, 0x06,
		0x2f, 0x61, 0x72, 0x69, 0x74, 0x68,
	}
	sd := descriptorpb.ServiceDescriptorProto{}
	proto.Unmarshal(serviceDescriptorRaw, &sd)
	return &sd
}
